# -*- coding: utf-8 -*-
"""Network entropy 2.0 (Vasya branch).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qboxRJpT_3sP_K7W-UWUa5fhNb9FMGef
"""

#@title t-dependent entropy { form-width: "300px" }
import numpy as np
import networkx as nx
import scipy
import scipy.sparse as sp
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from IPython.utils import io
import tqdm
#!pip install pydot

def get_laplacian_spectrum(A):
    A = A.astype(float)
    out_degrees = np.array(A.sum(axis=0)).ravel()
    D = sp.spdiags(out_degrees, [0], A.shape[0], A.shape[0], format='csr')
    L = D - A
    lap_spectrum = np.sort(np.linalg.eigvals(L))

    return lap_spectrum

def get_laplacian_spectrum(A):
    A = A.astype(float)
    out_degrees = np.array(A.sum(axis=0)).ravel()
    D = sp.spdiags(out_degrees, [0], A.shape[0], A.shape[0], format='csr')
    L = D - A
    lap_spectrum = np.sort(np.linalg.eigvals(L))

    return lap_spectrum


def spectral_entropy(lap_spectrum, t, verbose = 0):
    eigenvalues = np.exp(-t * lap_spectrum)
    norm_eigenvalues = np.trim_zeros(eigenvalues/np.sum(eigenvalues))

    if verbose:
        print('Laplacian eigenvalues:')
        print(lap_spectrum)
        print('exp eigenvalues:')
        print(eigenvalues)
        print('norm exp eigenvalues:')
        print(norm_eigenvalues)
        print('logs:')
        print(np.log2(norm_eigenvalues))

    #посчитали энтропию по формуле из статьи 
    #https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.041062
    
    S = -np.real(np.sum(np.multiply(norm_eigenvalues, np.log2(norm_eigenvalues))))
    return S


def free_entropy(lap_spectrum, t):
    eigenvalues = np.exp(-t * lap_spectrum)
    F = -np.log2(np.real(np.sum(eigenvalues)))
    return F

#%% @title Beautiful figure transformer { form-width: "300px" }
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pylab as pylab


def make_beautiful(ax):
    for axis in ['bottom','left']:
        ax.spines[axis].set_linewidth(4)
        ax.tick_params(width=4, direction = 'in', length = 8, pad=15)

    for axis in ['top','right']:
        ax.spines[axis].set_linewidth(0.0)

    ax.locator_params(axis='x', nbins=8)
    ax.locator_params(axis='y', nbins=8)
    ax.tick_params(axis='x', which='major', labelsize=26)
    ax.tick_params(axis='y', which='major', labelsize=26)

    ax.xaxis.label.set_size(30)
    ax.yaxis.label.set_size(30)
    
    params = {'legend.fontsize': 18,
              'axes.titlesize': 30,
    }
    
    pylab.rcParams.update(params)

    return ax


def create_default_figure(a=16, b=12):
    fig, ax = plt.subplots(figsize = (a,b))
    ax = make_beautiful(ax)

    return fig, ax

#%%"""# Comparison with random network"""

#@title New shuffling (recommended) { form-width: "300px" }
import warnings

def random_rewiring_dense_graph(a):

    if isinstance(a, np.ndarray):
        afull = a
        nelem = len(np.nonzero(a)[0])
    else:
        afull = a.A
        nelem = a.nnz
    
    if nelem != a.shape[0]**2 - a.shape[0]:
        #warnings.warn('Graph is not complete, proceding with gap filling trick')
        temp = 0.0001
    else:
        temp = 0

    psA = afull + np.full(a.shape, temp) - np.eye(a.shape[0])*temp
    vals = psA[np.nonzero(np.triu(psA))]
    np.random.shuffle(vals)

    tri = np.zeros(a.shape)
    tri[np.triu_indices(a.shape[0], 1)] = vals
    rewired = tri+tri.T
    res = rewired - np.full(a.shape, temp) + np.eye(a.shape[0])*temp

    return res

#%%"""# Structural connectomes"""

import os
import pandas as pd
import scipy.io
import glob
# from google.colab import drive
# drive.mount('/content/drive/', force_remount=True)

root = 'D:\Work\\Network_entropy\\connectomes' #'/content/drive/MyDrive/connectomes/'
ctrl_path = root + '\\controls'
pat_path = root + '\\patients'
metadata_path = root
annotation_path = root + '\\AAL_structures.csv' 

ctrl_names = glob.glob(ctrl_path + '\\*.mat')
pat_names = glob.glob(pat_path + '\\*.mat')
metadata = pd.read_csv(os.path.join(metadata_path, 'phen_with_entropy_with_model_name.csv'))

metadata_subjects = [s[1:23] for s in list(metadata['Subjects'].values)]
metadata_cdr = list(metadata['cdr'].values)
metadata_cdrdict = dict(zip(metadata_subjects, metadata_cdr))

cdrdict = {}
session_filename_dict = {}

for name in ctrl_names + pat_names:
    sub_name = name[len(ctrl_path)+1: len(ctrl_path) + 23]
    if sub_name in metadata_subjects:
        cdrdict[sub_name] = metadata_cdrdict[sub_name]
        session_filename_dict[sub_name] = name

cdrdict

def get_adj_from_session_name(sname):
    name = session_filename_dict[sname]

    if cdrdict[sname] == 0:
        data = scipy.io.loadmat(os.path.join(ctrl_path, name))
    else:
        data = scipy.io.loadmat(os.path.join(pat_path, name))
        
    #mat = data['brainnetome246_sift_invnodevol_radius2_count_connectivity']
    mat = data['aal116_sift_invnodevol_radius2_count_connectivity']
    np.fill_diagonal(mat, 0)
    #mat = data['brainnetome246_sift_radius2_count_connectivity']
    return mat

name = ctrl_names[0]
data = scipy.io.loadmat(os.path.join(ctrl_path, name))

data

"""# Truncation"""

def get_adj_from_session_name_router(name):

    dname = session_filename_dict[name]

    if cdrdict[name] == 0:
        data = scipy.io.loadmat(os.path.join(ctrl_path, dname))
    else:
        data = scipy.io.loadmat(os.path.join(pat_path, dname))
        
    mat = data['aal116_sift_invnodevol_radius2_count_connectivity']
    np.fill_diagonal(mat, 0)

    return mat

def get_truncated_net(A, thr, thr_mode = '<'):
    if thr_mode == '>':
        A[np.where(A>thr)] = 0
    elif thr_mode == '<':
        A[np.where(A<thr)] = 0

    return A

#%% """# Example"""
import pandas as pd

def drop_cerebellum(A, num = 90):
    return A[:num, :num]

def get_strongest_connections(A, mode = 'thres', percentile = 95, thr = 10, rate = 0.1, top_n = 20, top_rate = 0.05):
    conns = np.array([[a, row, col] for row, B in enumerate(A) for col, a in enumerate(B) if row < col])   
    conns = conns[conns[:,0].argsort()] #sorting by value
    conns = conns[::-1]                 #in descending order
    if mode == 'percent':
        thr = np.percentile(conns, percentile, axis=0)[0]
        conns = np.array([row for row in conns if row[0] > thr])
    elif mode == 'rate':
        thr = np.max(conns[:,0])*rate
        conns = np.array([row for row in conns if row[0] > thr])        
    elif mode == 'thres':
        conns = np.array([row for row in conns if row[0] > thr])
    elif mode == 'top_n':
        conns = conns[:top_n, :]
    elif mode == 'top_rate':
        top_n = int(len(conns)*top_rate)
        conns = conns[:top_n, :]
    return conns

def get_weakest_connections(A, mode = 'thres', percentile = 95, thr = 10, rate = 0.1, top_n = 20, top_rate = 0.05):
    conns = np.array([[a, row, col] for row, B in enumerate(A) for col, a in enumerate(B) if row < col])   
    conns = conns[conns[:,0].argsort()] #sorting by value in ascending order
    conns = conns[conns[:,0] > 0]                 #
    if mode == 'percent':
        thr = np.percentile(conns, percentile, axis=0)[0]
        conns = np.array([row for row in conns if row[0] < thr])
    elif mode == 'rate':
        thr = np.max(conns[:,0])*rate
        conns = np.array([row for row in conns if row[0] < thr])        
    elif mode == 'thres':
        conns = np.array([row for row in conns if row[0] < thr])
    elif mode == 'top_n':
        conns = conns[:top_n, :]
    elif mode == 'top_rate':
        top_n = int(len(conns)*top_rate)
        conns = conns[:top_n, :]
    return conns



def get_connection_stats(conns, labels):
    ips = [c[0] for c in conns if labels[int(c[1])] == labels[int(c[2])]]
    cons = [c[0] for c in conns if labels[int(c[1])] != labels[int(c[2])]]
    return len(ips), np.sum(ips), len(cons), np.sum(cons)


def LobeColor(lobe):
    return {
    'FRON':[1,0,0],        #red
    'LIMB':[0,0.7,0],      #green
    'OCCI':[0,0,1],        #blue
    'PARI':[0,1,1],        #cyan
    'BASG':[0.5,0.25,0.2], #brown
    'THAL':[1,0.5,0.1],    #orange
    'TEMP':[0.5,0,1]}.get(lobe)      #violet


def Draw_connections(ax, conns, aliases, lobes, xx, yy, out_fname, con_color = 'black'):
    # fig = plt.figure(figsize = (10,10))
    # ax = fig.add_subplot(111)
    for con in conns:
        plt.plot([xx[int(con[1])],xx[int(con[2])]], [yy[int(con[1])],yy[int(con[2])]], color = con_color, linewidth = con[0]/5 + 0.5, zorder = 0.0)
    for alias, lobe, x, y in zip(aliases, lobes, xx, yy):
        circ = Circle((x,y), 5, facecolor = LobeColor(lobe), edgecolor = 'black', zorder = 1.0)
        ax.add_patch(circ)
        plt.text(x-12,y, alias)
    # plt.savefig(out_fname, dpi = 150)
    # plt.close()   
        

anno = pd.read_csv(annotation_path)
al = list(anno['Alias'].values)
lobes = list(anno['Lobe'].values)
hemis = list(anno['Hemisphere'].values)
xx = list(anno['x'].values) 
yy = list(anno['y'].values) 

namelist = list(cdrdict.keys())
# name = namelist[0]

n_strong_conns = 0
h_stat = np.zeros(4)  #arrays for stat storage: [n_local, sum_local, n_inter, sum_inter]
l_stat = np.zeros(4)

n_weak_conns = 0
hw_stat = np.zeros(4)  
lw_stat = np.zeros(4)
A_av = np.zeros((90,90))

for name in namelist:
    # print(f'Session {name}: cdr {cdrdict[name]}')
    
    A = get_adj_from_session_name_router(name)
    A = drop_cerebellum(A)
    A = get_truncated_net(A, thr = 0.5, thr_mode = '<')
    A_av += A
    s_conns = get_strongest_connections(A, mode = 'rate', rate = 0.1)
    w_conns = get_weakest_connections(A, mode = 'rate', rate = 0.1)
    # for c in conns:
    #     print(f'{c[0]:.2f}\t{lobes[int(c[1])]}-{lobes[int(c[2])]}\t{hemis[int(c[1])]}-{hemis[int(c[2])]}\t{al[int(c[1])]}-{al[int(c[2])]}')
       
    n_strong_conns += len(s_conns)
    h_stat += get_connection_stats(s_conns, hemis)
    l_stat += get_connection_stats(s_conns, lobes)
    
    n_weak_conns += len(w_conns)
    hw_stat += get_connection_stats(w_conns, hemis)
    lw_stat += get_connection_stats(w_conns, lobes)
    
print(f'{n_strong_conns} of {4005*len(namelist)} strong connections ({n_strong_conns*100/(4005*len(namelist)):.2f} %)')    
print(f'{h_stat[0]*100/n_strong_conns:.2f} % ipsilateral connections, average value {h_stat[1]/h_stat[0]:.2f}')
print(f'{h_stat[2]*100/n_strong_conns:.2f}% contrlateral connections, average value {h_stat[3]/h_stat[2]:.2f}')
print(f'{l_stat[0]*100/n_strong_conns:.2f} % local connections, average value {l_stat[1]/l_stat[0]:.2f}')
print(f'{l_stat[2]*100/n_strong_conns:.2f} % interlobular connections, average value {l_stat[3]/l_stat[2]:.2f}')
print('\n')

print(f'{n_weak_conns} of {4005*len(namelist)} weak connections ({n_weak_conns*100/(4005*len(namelist)):.2f} %)')    
print(f'{hw_stat[0]*100/n_weak_conns:.2f} % ipsilateral connections, average value {hw_stat[1]/hw_stat[0]:.2f}')
print(f'{hw_stat[2]*100/n_weak_conns:.2f}% contrlateral connections, average value {hw_stat[3]/hw_stat[2]:.2f}')
print(f'{lw_stat[0]*100/n_weak_conns:.2f} % local connections, average value {lw_stat[1]/lw_stat[0]:.2f}')
print(f'{lw_stat[2]*100/n_weak_conns:.2f} % interlobular connections, average value {lw_stat[3]/lw_stat[2]:.2f}')

A_av /= len(namelist) 
av_s_conns = get_strongest_connections(A_av, mode = 'rate', rate = 0.1)
av_w_conns = get_weakest_connections(A_av, mode = 'rate', rate = 0.1)

fig = plt.figure(figsize = (10,10))
ax = fig.add_subplot(111)
out_fname = root + '\\connections.png'

Draw_connections(ax, av_w_conns, al, lobes, xx, yy, out_fname = root + '\\connections.png', con_color = [0.5, 0.5, 0.5])
Draw_connections(ax, av_s_conns, al, lobes, xx, yy, out_fname = root + '\\connections.png', con_color = 'black')

plt.savefig(out_fname, dpi = 150)
plt.close() 



